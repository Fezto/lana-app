/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyOauthTokenAuthTokenPost,
  ForgotPasswordRequest,
  HTTPValidationError,
  LoginData,
  LogoutRequest,
  OauthTokenAuthTokenPost200,
  RefreshTokenRequest,
  ResetPasswordRequest,
  Token,
  UserCreate,
  UserRead,
  VerifyEmailParams
} from './schemas';

import { customInstance } from './custom-instance';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Oauth Token
 */
export const oauthTokenAuthTokenPost = (
    bodyOauthTokenAuthTokenPost: BodyOauthTokenAuthTokenPost,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyOauthTokenAuthTokenPost.grant_type !== undefined && bodyOauthTokenAuthTokenPost.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyOauthTokenAuthTokenPost.grant_type)
 }
formUrlEncoded.append(`username`, bodyOauthTokenAuthTokenPost.username)
formUrlEncoded.append(`password`, bodyOauthTokenAuthTokenPost.password)
if(bodyOauthTokenAuthTokenPost.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyOauthTokenAuthTokenPost.scope)
 }
if(bodyOauthTokenAuthTokenPost.client_id !== undefined && bodyOauthTokenAuthTokenPost.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyOauthTokenAuthTokenPost.client_id)
 }
if(bodyOauthTokenAuthTokenPost.client_secret !== undefined && bodyOauthTokenAuthTokenPost.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyOauthTokenAuthTokenPost.client_secret)
 }

      return customInstance<OauthTokenAuthTokenPost200>(
      {url: `/auth/token`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      options);
    }
  


export const getOauthTokenAuthTokenPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oauthTokenAuthTokenPost>>, TError,{data: BodyOauthTokenAuthTokenPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof oauthTokenAuthTokenPost>>, TError,{data: BodyOauthTokenAuthTokenPost}, TContext> => {

const mutationKey = ['oauthTokenAuthTokenPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof oauthTokenAuthTokenPost>>, {data: BodyOauthTokenAuthTokenPost}> = (props) => {
          const {data} = props ?? {};

          return  oauthTokenAuthTokenPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OauthTokenAuthTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof oauthTokenAuthTokenPost>>>
    export type OauthTokenAuthTokenPostMutationBody = BodyOauthTokenAuthTokenPost
    export type OauthTokenAuthTokenPostMutationError = HTTPValidationError

    /**
 * @summary Oauth Token
 */
export const useOauthTokenAuthTokenPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oauthTokenAuthTokenPost>>, TError,{data: BodyOauthTokenAuthTokenPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof oauthTokenAuthTokenPost>>,
        TError,
        {data: BodyOauthTokenAuthTokenPost},
        TContext
      > => {

      const mutationOptions = getOauthTokenAuthTokenPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Register
 */
export const registerUser = (
    userCreate: UserCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRead>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      options);
    }
  


export const getRegisterUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUser>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUserMutationResult = NonNullable<Awaited<ReturnType<typeof registerUser>>>
    export type RegisterUserMutationBody = UserCreate
    export type RegisterUserMutationError = HTTPValidationError

    /**
 * @summary Register
 */
export const useRegisterUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerUser>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Login
 */
export const loginUser = (
    loginData: LoginData,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginData, signal
    },
      options);
    }
  


export const getLoginUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginData}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginData}, TContext> => {

const mutationKey = ['loginUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginUser>>, {data: LoginData}> = (props) => {
          const {data} = props ?? {};

          return  loginUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginUserMutationResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>
    export type LoginUserMutationBody = LoginData
    export type LoginUserMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginData}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginUser>>,
        TError,
        {data: LoginData},
        TContext
      > => {

      const mutationOptions = getLoginUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Refresh Tokens
 */
export const refreshTokens = (
    refreshTokenRequest: RefreshTokenRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenRequest, signal
    },
      options);
    }
  


export const getRefreshTokensMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokens>>, TError,{data: RefreshTokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof refreshTokens>>, TError,{data: RefreshTokenRequest}, TContext> => {

const mutationKey = ['refreshTokens'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshTokens>>, {data: RefreshTokenRequest}> = (props) => {
          const {data} = props ?? {};

          return  refreshTokens(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokensMutationResult = NonNullable<Awaited<ReturnType<typeof refreshTokens>>>
    export type RefreshTokensMutationBody = RefreshTokenRequest
    export type RefreshTokensMutationError = HTTPValidationError

    /**
 * @summary Refresh Tokens
 */
export const useRefreshTokens = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokens>>, TError,{data: RefreshTokenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshTokens>>,
        TError,
        {data: RefreshTokenRequest},
        TContext
      > => {

      const mutationOptions = getRefreshTokensMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Verify Email
 */
export const verifyEmail = (
    params: VerifyEmailParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/verify-email`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getVerifyEmailQueryKey = (params: VerifyEmailParams,) => {
    return [`/auth/verify-email`, ...(params ? [params]: [])] as const;
    }

    
export const getVerifyEmailQueryOptions = <TData = Awaited<ReturnType<typeof verifyEmail>>, TError = HTTPValidationError>(params: VerifyEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVerifyEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyEmail>>> = ({ signal }) => verifyEmail(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VerifyEmailQueryResult = NonNullable<Awaited<ReturnType<typeof verifyEmail>>>
export type VerifyEmailQueryError = HTTPValidationError


export function useVerifyEmail<TData = Awaited<ReturnType<typeof verifyEmail>>, TError = HTTPValidationError>(
 params: VerifyEmailParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyEmail>>,
          TError,
          Awaited<ReturnType<typeof verifyEmail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyEmail<TData = Awaited<ReturnType<typeof verifyEmail>>, TError = HTTPValidationError>(
 params: VerifyEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyEmail>>,
          TError,
          Awaited<ReturnType<typeof verifyEmail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyEmail<TData = Awaited<ReturnType<typeof verifyEmail>>, TError = HTTPValidationError>(
 params: VerifyEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Verify Email
 */

export function useVerifyEmail<TData = Awaited<ReturnType<typeof verifyEmail>>, TError = HTTPValidationError>(
 params: VerifyEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVerifyEmailQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Forgot Password
 */
export const forgotPassword = (
    forgotPasswordRequest: ForgotPasswordRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: forgotPasswordRequest, signal
    },
      options);
    }
  


export const getForgotPasswordMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext> => {

const mutationKey = ['forgotPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPassword>>, {data: ForgotPasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  forgotPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPassword>>>
    export type ForgotPasswordMutationBody = ForgotPasswordRequest
    export type ForgotPasswordMutationError = HTTPValidationError

    /**
 * @summary Forgot Password
 */
export const useForgotPassword = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof forgotPassword>>,
        TError,
        {data: ForgotPasswordRequest},
        TContext
      > => {

      const mutationOptions = getForgotPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Reset Password
 */
export const resetPassword = (
    resetPasswordRequest: ResetPasswordRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordRequest, signal
    },
      options);
    }
  


export const getResetPasswordMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: ResetPasswordRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: ResetPasswordRequest}, TContext> => {

const mutationKey = ['resetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetPassword>>, {data: ResetPasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  resetPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>
    export type ResetPasswordMutationBody = ResetPasswordRequest
    export type ResetPasswordMutationError = HTTPValidationError

    /**
 * @summary Reset Password
 */
export const useResetPassword = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: ResetPasswordRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetPassword>>,
        TError,
        {data: ResetPasswordRequest},
        TContext
      > => {

      const mutationOptions = getResetPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Logout
 */
export const logoutUser = (
    logoutRequest: LogoutRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/logout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: logoutRequest, signal
    },
      options);
    }
  


export const getLogoutUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutUser>>, TError,{data: LogoutRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof logoutUser>>, TError,{data: LogoutRequest}, TContext> => {

const mutationKey = ['logoutUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutUser>>, {data: LogoutRequest}> = (props) => {
          const {data} = props ?? {};

          return  logoutUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutUserMutationResult = NonNullable<Awaited<ReturnType<typeof logoutUser>>>
    export type LogoutUserMutationBody = LogoutRequest
    export type LogoutUserMutationError = HTTPValidationError

    /**
 * @summary Logout
 */
export const useLogoutUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutUser>>, TError,{data: LogoutRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logoutUser>>,
        TError,
        {data: LogoutRequest},
        TContext
      > => {

      const mutationOptions = getLogoutUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    